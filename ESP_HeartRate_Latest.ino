#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <DFRobot_Heartrate.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>
#include <time.h>

// Bitmaps

static const unsigned char PROGMEM image_passport_bottom_bits[] = { 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1,
                                                                    0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xa0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xa0, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xa0, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x90, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x80, 0x03, 0x00, 0xcf, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xc0, 0x06, 0x00, 0x60, 0x61, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const unsigned char PROGMEM image_Background_bits[] = { 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xff, 0xed, 0xaa, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x81,
                                                               0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x00, 0x00, 0x00, 0x47, 0xff, 0xff, 0xff, 0xfe, 0xbc, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6d, 0x57, 0xff, 0x20, 0x00, 0x00, 0x00, 0x01, 0x82, 0x7f, 0xff, 0xff, 0x55, 0x7f, 0xff, 0xfc, 0x80, 0x00, 0x00, 0x9f, 0xff, 0xff, 0xff, 0xd5, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1f, 0xff, 0xfe, 0x40, 0x00, 0x00, 0x00, 0x01, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xbf, 0xfe, 0x3f, 0xff, 0xff, 0x36, 0xff, 0xff, 0xff, 0xad, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xfe };

static const unsigned char PROGMEM image_battery_full_bits[] = { 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x10, 0x00, 0x01, 0x16, 0xdb, 0x6d, 0x76, 0xdb, 0x6d, 0x86, 0xdb, 0x6d, 0x86, 0xdb, 0x6d, 0x86, 0xdb, 0x6d, 0x86, 0xdb, 0x6d, 0x86, 0xdb, 0x6d, 0x76, 0xdb, 0x6d, 0x16, 0xdb, 0x6d, 0x10, 0x00, 0x01, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const unsigned char PROGMEM image_battery_50_bits[] = { 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x10, 0x00, 0x01, 0x10, 0x03, 0x6d, 0x70, 0x03, 0x6d, 0x80, 0x03, 0x6d, 0x80, 0x03, 0x6d, 0x80, 0x03, 0x6d, 0x80, 0x03, 0x6d, 0x80, 0x03, 0x6d, 0x70, 0x03, 0x6d, 0x10, 0x03, 0x6d, 0x10, 0x00, 0x01, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const unsigned char PROGMEM image_battery_17_bits[] = { 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x10, 0x00, 0x01, 0x10, 0x00, 0x0d, 0x70, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x80, 0x00, 0x0d, 0x70, 0x00, 0x0d, 0x10, 0x00, 0x0d, 0x10, 0x00, 0x01, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const unsigned char PROGMEM image_bluetooth_connected_bits[] = { 0x01, 0x00, 0x02, 0x80, 0x02, 0x40, 0x22, 0x20, 0x12, 0x20, 0x4a, 0x48, 0x26, 0x90, 0x33, 0x30, 0x26, 0x90, 0x4a, 0x48, 0x12, 0x20, 0x22, 0x20, 0x02, 0x40, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00 };

static const unsigned char PROGMEM image_bluetooth_not_connected_bits[] = { 0x02, 0x00, 0x83, 0x00, 0x42, 0x80, 0x22, 0x40, 0x12, 0x20, 0x08, 0x20, 0x04, 0x40, 0x02, 0x00, 0x05, 0x00, 0x0a, 0x80, 0x12, 0x40, 0x22, 0x20, 0x02, 0x50, 0x02, 0x88, 0x01, 0x04, 0x00, 0x00 };

static const unsigned char PROGMEM image_cards_hearts_bits[] = { 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfe, 0x7f, 0xfc, 0x3f, 0xf8, 0x1f, 0xf0, 0x0f, 0xe0, 0x07, 0xc0, 0x03, 0x80, 0x01, 0x00, 0x00, 0x00 };


// Display configuration
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET 4
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Heart rate sensor
#define heartratePin 0
DFRobot_Heartrate heartrate(ANALOG_MODE);

// BLE Configuration
BLEServer *pServer = NULL;
BLECharacteristic *pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;
const char *serviceUUID = "180D";
const char *charUUID = "2A37";

// Current Time Service
#define CURRENT_TIME_SERVICE_UUID "1805"
#define CURRENT_TIME_CHAR_UUID "2A2B"
#define LOCAL_TIME_INFO_CHAR_UUID "2A0F"
uint8_t currentTime[10] = { 0 };
bool timeReceived = false;

// Display state tracking
uint8_t lastRateValue = 100;
uint8_t lastHour = 13;
uint8_t lastMinute = 69;
bool lastConnectionState = true;

// Time management
time_t now;
struct tm timeinfo;
bool timeInitialized = false;
uint8_t lastDisplayMinute = 255;

void handleTimeUpdate() {

  timeinfo.tm_year = (currentTime[0] | (currentTime[1] << 8)) - 1900;
  timeinfo.tm_mon = currentTime[2] - 1;
  timeinfo.tm_mday = currentTime[3];
  timeinfo.tm_hour = currentTime[4];
  timeinfo.tm_min = currentTime[5];
  timeinfo.tm_sec = currentTime[6];

  if (timeinfo.tm_mon < 0 || timeinfo.tm_mon > 11 || timeinfo.tm_mday < 1 || timeinfo.tm_mday > 31 || timeinfo.tm_hour > 23 || timeinfo.tm_min > 59) {
    Serial.println("Invalid BLE time received");
    return;
  }

  timeinfo.tm_min += 30;
  if (timeinfo.tm_min >= 60) {
    timeinfo.tm_min -= 60;
    timeinfo.tm_hour += 1;
  }
  timeinfo.tm_hour += 5;
  if (timeinfo.tm_hour >= 24) {
    timeinfo.tm_hour -= 24;
    timeinfo.tm_mday += 1;
  }

  if (timeinfo.tm_hour >= 24 || timeinfo.tm_min >= 60) {
    Serial.println("Invalid time after conversion");
    return;
  }

  time_t t = mktime(&timeinfo);
  struct timeval tv = { t, 0 };
  settimeofday(&tv, NULL);

  updateTime(timeinfo.tm_hour, timeinfo.tm_min);
  timeReceived = true;
  
  Serial.printf("Time set to: %02d:%02d IST\n", timeinfo.tm_hour, timeinfo.tm_min);
}

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer *pServer) {
    deviceConnected = true;
  }
  void onDisconnect(BLEServer *pServer) {
    deviceConnected = false;
  }
};

class CurrentTimeCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) {
    String value = pCharacteristic->getValue();
    if (value.length() >= 10) {
      for (int i = 0; i < 10; i++) {
        currentTime[i] = value[i];
      }
      handleTimeUpdate();
    }
  }
};

void initializeDisplay() {
  display.clearDisplay();

  display.drawBitmap(0, 46, image_passport_bottom_bits, 128, 18, SSD1306_WHITE);
  display.drawBitmap(1, 9, image_Background_bits, 128, 11, SSD1306_WHITE);

  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(107, 36);
  display.print("BPM");
  display.setCursor(62, 30);
  display.print("M");
  display.setCursor(29, 30);
  display.print("H");

  display.drawBitmap(11, 40, image_battery_full_bits, 24, 16, SSD1306_WHITE);
  display.drawBitmap(108, 20, image_cards_hearts_bits, 15, 16, SSD1306_WHITE);

  updateHeartRate(0);
  updateTime(11, 59);
  updateBluetoothIcon(false);

  display.display();
}

void updateHeartRate(uint8_t rateValue) {
  if (rateValue == lastRateValue) return;

  display.fillRect(72, 23, 34, 22, SSD1306_BLACK);
  display.setTextSize(3);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(72, 23);
  display.print(rateValue ? rateValue : 73);

  display.display();
  lastRateValue = rateValue;
}

void updateTime(uint8_t hour, uint8_t minute) {
  bool needUpdate = false;

  if (hour != lastHour) {
    display.fillRect(4, 23, 24, 16, SSD1306_BLACK);
    display.setTextSize(2);
    display.setCursor(4, 23);
    if (hour < 10) display.print("0");
    display.print(hour);
    lastHour = hour;
    needUpdate = true;
  }

  if (minute != lastMinute) {
    display.fillRect(37, 23, 24, 16, SSD1306_BLACK);
    display.setTextSize(2);
    display.setCursor(37, 23);
    if (minute < 10) display.print("0");
    display.print(minute);
    lastMinute = minute;
    needUpdate = true;
  }

  if (needUpdate) {
    display.display();
  }
}

void updateBluetoothIcon(bool connected) {
  if (connected == lastConnectionState) return;

  display.fillRect(41, 40, 14, 16, SSD1306_BLACK);
  display.drawBitmap(41, 40,
                     connected ? image_bluetooth_connected_bits : image_bluetooth_not_connected_bits,
                     14, 16, SSD1306_WHITE);

  display.display();
  lastConnectionState = connected;
}

void setup() {
  Serial.begin(115200);
  analogReadResolution(12);
  pinMode(heartratePin, INPUT);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;
  }
  initializeDisplay();

  if (!timeInitialized) {
    timeinfo.tm_hour = 11;
    timeinfo.tm_min = 59;
    handleTimeUpdate();
  }

  // Initialize BLE
  BLEDevice::init("HeartRateMonitor");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  // Heart Rate Service
  BLEService *pHeartService = pServer->createService(BLEUUID((uint16_t)0x180D));
  pCharacteristic = pHeartService->createCharacteristic(
    BLEUUID((uint16_t)0x2A37),
    BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic->addDescriptor(new BLE2902());
  pHeartService->start();

  // Current Time Service
  BLEService *pTimeService = pServer->createService(BLEUUID((uint16_t)0x1805));

  // Current Time Characteristic
  BLECharacteristic *pCurrentTimeCharacteristic = pTimeService->createCharacteristic(
    BLEUUID((uint16_t)0x2A2B),
    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_NOTIFY);
  pCurrentTimeCharacteristic->addDescriptor(new BLE2902());
  pCurrentTimeCharacteristic->setCallbacks(new CurrentTimeCharacteristicCallbacks());

  // Local Time Information Characteristic
  BLECharacteristic *pLocalTimeCharacteristic = pTimeService->createCharacteristic(
    BLEUUID((uint16_t)0x2A0F),
    BLECharacteristic::PROPERTY_READ);
  uint8_t localTimeInfo[2] = { 0x00, 0x00 };  // No DST offset, no time zone
  pLocalTimeCharacteristic->setValue(localTimeInfo, 2);

  pTimeService->start();

  // Start advertising
  BLEAdvertising *pAdvertising = pServer->getAdvertising();
  pAdvertising->addServiceUUID(BLEUUID((uint16_t)0x180D));
  pAdvertising->addServiceUUID(BLEUUID((uint16_t)0x1805));
  pAdvertising->start();
  Serial.println("Waiting for BLE client connection...");
}

void loop() {
  if (!deviceConnected && oldDeviceConnected) {
    delay(500);
    pServer->startAdvertising();
    Serial.println("Advertising started");
    oldDeviceConnected = deviceConnected;
  }
  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
  }

  // Update time every second
  time(&now);
  localtime_r(&now, &timeinfo);

  uint8_t displayHour = timeinfo.tm_hour;
  uint8_t displayMinute = timeinfo.tm_min;

  // Detect minute changes
  if (displayMinute != lastDisplayMinute) {
    updateTime(displayHour, displayMinute);
    lastDisplayMinute = displayMinute;
  }

  // Heart rate handling
  uint8_t rateValue = heartrate.getValue(heartratePin);
  rateValue = heartrate.getRate();
  uint8_t displayRate = 99;
  if (rateValue > 0 && rateValue <= 250) {
    displayRate = (rateValue > 99) ? 99 : rateValue;
    updateHeartRate(displayRate);

    if (deviceConnected) {
      uint8_t heartRateData[2] = { 0x00, rateValue };
      pCharacteristic->setValue(heartRateData, 2);
      pCharacteristic->notify();
      delay(10);
    }
  }
  updateBluetoothIcon(deviceConnected);
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug > 5000) {
    lastDebug = millis();
    Serial.printf("Current IST: %02d:%02d, Connected: %d\n",
                  displayHour, displayMinute, deviceConnected);
  }
  delay(20);
}